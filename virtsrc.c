/*
 *  ALSA Virtual Soundcard : Signal Source (alsa-vss).
 *
 *  Based on Minimal virtual oscillator (minivosc) soundcard.
 *
 *  Based on Loopback soundcard (aloop-kernel.c):
 *  Original code:
 *  Copyright (c) by Jaroslav Kysela <perex@perex.cz>
 *
 *  More accurate positioning and full-duplex support:
 *  Copyright (c) Ahmet Ä°nan <ainan at mathematik.uni-freiburg.de>
 *
 *  Major (almost complete) rewrite:
 *  Copyright (c) by Takashi Iwai <tiwai@suse.de>
 *
 *  with snippets from Ben Collins: Writing an ALSA driver
 *  http://ben-collins.blogspot.com/2010/04/writing-alsa-driver.html
 *
 *  minivosc specific parts:
 *  Copyright (c) by Smilen Dimitrov <sd at imi.aau.dk>
 *
 *  alsa-vsss specific parts:
 *  Copyright (c) by Brian Marchant <brian at brianmarchant.com>
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program; if not, write to the Free Software
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
 *
 */

static int debug = 1;
/* Use our own dbg macro http://www.n1ywb.com/projects/darts/darts-usb/darts-usb.c*/
#undef dbg
#define dbg(format, arg...) do { if (debug) printk(KERN_DEBUG __FILE__ ": " format "\n" , ## arg); } while (0)
#define dbg2(format, arg...) do { if (debug) printk( ": " format "\n" , ## arg); } while (0)


/* Here is our user defined breakpoint to */
/* initiate communication with remote (k)gdb */
/* don't use if not actually using kgdb */
//#define BREAKPOINT() asm("   int $3");


// copy from aloop-kernel.c:
#include <linux/init.h>
#include <linux/module.h>
#include <linux/jiffies.h>
#include <linux/slab.h>
#include <linux/time.h>
#include <linux/wait.h>
#include <linux/moduleparam.h>
#include <linux/platform_device.h>
#include <sound/core.h>
#include <sound/control.h>
#include <sound/pcm.h>
#include <sound/initval.h>
#include <linux/version.h>

MODULE_AUTHOR("bmarchant");
MODULE_DESCRIPTION("virtual-source");
MODULE_LICENSE("GPL");
MODULE_SUPPORTED_DEVICE("{{ALSA,virtual-source}}");

static int index[SNDRV_CARDS] = SNDRV_DEFAULT_IDX;	/* Index 0-MAX */
static char *id[SNDRV_CARDS] = SNDRV_DEFAULT_STR;	/* ID for this card */
static int enable[SNDRV_CARDS] = {1, [1 ... (SNDRV_CARDS - 1)] = 0};

static struct platform_device *devices[SNDRV_CARDS];

#define byte_pos(x)	((x) / HZ)
#define frac_pos(x)	((x) * HZ)

#define MAX_BUFFER (32 * 48)
static struct snd_pcm_hardware vss_pcm_hw =
{
	.info = (SNDRV_PCM_INFO_MMAP |
	SNDRV_PCM_INFO_INTERLEAVED |
	SNDRV_PCM_INFO_BLOCK_TRANSFER |
	SNDRV_PCM_INFO_MMAP_VALID),
	.formats          = SNDRV_PCM_FMTBIT_U8,
	.rates            = SNDRV_PCM_RATE_48000,
	.rate_min         = 48000,
	.rate_max         = 48000,
	.channels_min     = 1,
	.channels_max     = 1,
	.buffer_bytes_max = MAX_BUFFER, //(32 * 48) = 1536,
	.period_bytes_min = 48,
	.period_bytes_max = 48,
	.periods_min      = 1,
	.periods_max      = 32,
};


struct vss_device
{
	struct snd_card *card;
	struct snd_pcm *pcm;
	const struct vss_pcm_ops *timer_ops;
	/*
	* we have only one substream, so all data in this struct
	*/
	/* copied from struct loopback: */
	struct mutex cable_lock;
	/* copied from struct loopback_cable: */
	/* PCM parameters */
	unsigned int pcm_period_size;
	unsigned int pcm_bps;		/* bytes per second */
	/* flags */
	unsigned int valid;
	unsigned int running;
	unsigned int period_update_pending :1;
	/* timer stuff */
	unsigned int irq_pos;		/* fractional IRQ position */
	unsigned int period_size_frac;
	unsigned long last_jiffies;
	struct timer_list timer;
	/* copied from struct loopback_pcm: */
	struct snd_pcm_substream *substream;
	unsigned int pcm_buffer_size;
	unsigned int buf_pos;	/* position in buffer */
	unsigned int silent_size;
	/* added for waveform: */
	unsigned int wf_src_pos;	/* position in waveform array */
};

/*
** Single-cycle sinewave, 1kHz at 48kHz sample-rate (480 points, max amplitude 127/32767).
** Generated by https://www.daycounter.com/Calculators/Sine-Generator-Calculator2.phtml
*/
static int8_t sine_1k_data8[] = {
			0x40,0x40,0x41,0x42,0x43,0x44,0x44,0x45,0x46,0x47,0x48,0x49,0x49,0x4a,0x4b,0x4c,
			0x4d,0x4e,0x4e,0x4f,0x50,0x51,0x52,0x52,0x53,0x54,0x55,0x55,0x56,0x57,0x58,0x59,
			0x59,0x5a,0x5b,0x5c,0x5c,0x5d,0x5e,0x5f,0x5f,0x60,0x61,0x61,0x62,0x63,0x63,0x64,
			0x65,0x65,0x66,0x67,0x67,0x68,0x69,0x69,0x6a,0x6b,0x6b,0x6c,0x6c,0x6d,0x6e,0x6e,
			0x6f,0x6f,0x70,0x70,0x71,0x71,0x72,0x72,0x73,0x73,0x74,0x74,0x75,0x75,0x76,0x76,
			0x76,0x77,0x77,0x78,0x78,0x78,0x79,0x79,0x7a,0x7a,0x7a,0x7a,0x7b,0x7b,0x7b,0x7c,
			0x7c,0x7c,0x7c,0x7d,0x7d,0x7d,0x7d,0x7d,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7f,
			0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,0x7f,
			0x7f,0x7f,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7e,0x7d,0x7d,0x7d,0x7d,0x7d,0x7c,0x7c,
			0x7c,0x7c,0x7b,0x7b,0x7b,0x7a,0x7a,0x7a,0x7a,0x79,0x79,0x78,0x78,0x78,0x77,0x77,
			0x76,0x76,0x76,0x75,0x75,0x74,0x74,0x73,0x73,0x72,0x72,0x71,0x71,0x70,0x70,0x6f,
			0x6f,0x6e,0x6e,0x6d,0x6c,0x6c,0x6b,0x6b,0x6a,0x69,0x69,0x68,0x67,0x67,0x66,0x65,
			0x65,0x64,0x63,0x63,0x62,0x61,0x61,0x60,0x5f,0x5f,0x5e,0x5d,0x5c,0x5c,0x5b,0x5a,
			0x59,0x59,0x58,0x57,0x56,0x55,0x55,0x54,0x53,0x52,0x52,0x51,0x50,0x4f,0x4e,0x4e,
			0x4d,0x4c,0x4b,0x4a,0x49,0x49,0x48,0x47,0x46,0x45,0x44,0x44,0x43,0x42,0x41,0x40,
			0x40,0x3f,0x3e,0x3d,0x3c,0x3b,0x3b,0x3a,0x39,0x38,0x37,0x36,0x36,0x35,0x34,0x33,
			0x32,0x31,0x31,0x30,0x2f,0x2e,0x2d,0x2d,0x2c,0x2b,0x2a,0x2a,0x29,0x28,0x27,0x26,
			0x26,0x25,0x24,0x23,0x23,0x22,0x21,0x20,0x20,0x1f,0x1e,0x1e,0x1d,0x1c,0x1c,0x1b,
			0x1a,0x1a,0x19,0x18,0x18,0x17,0x16,0x16,0x15,0x14,0x14,0x13,0x13,0x12,0x11,0x11,
			0x10,0x10,0xf,0xf,0xe,0xe,0xd,0xd,0xc,0xc,0xb,0xb,0xa,0xa,0x9,0x9,
			0x9,0x8,0x8,0x7,0x7,0x7,0x6,0x6,0x5,0x5,0x5,0x5,0x4,0x4,0x4,0x3,
			0x3,0x3,0x3,0x2,0x2,0x2,0x2,0x2,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x0,
			0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
			0x0,0x0,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x2,0x2,0x2,0x2,0x2,0x3,0x3,
			0x3,0x3,0x4,0x4,0x4,0x5,0x5,0x5,0x5,0x6,0x6,0x7,0x7,0x7,0x8,0x8,
			0x9,0x9,0x9,0xa,0xa,0xb,0xb,0xc,0xc,0xd,0xd,0xe,0xe,0xf,0xf,0x10,
			0x10,0x11,0x11,0x12,0x13,0x13,0x14,0x14,0x15,0x16,0x16,0x17,0x18,0x18,0x19,0x1a,
			0x1a,0x1b,0x1c,0x1c,0x1d,0x1e,0x1e,0x1f,0x20,0x20,0x21,0x22,0x23,0x23,0x24,0x25,
			0x26,0x26,0x27,0x28,0x29,0x2a,0x2a,0x2b,0x2c,0x2d,0x2d,0x2e,0x2f,0x30,0x31,0x31,
			0x32,0x33,0x34,0x35,0x36,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3b,0x3c,0x3d,0x3e,0x3f,
			};

#ifdef VSS_ALLOW_16_BIT
static int16_t sine_1k_data16[] = {
			0x4000,0x40d6,0x41ac,0x4283,0x4359,0x442f,0x4505,0x45db,0x46b0,0x4785,0x485a,0x492e,0x4a02,0x4ad6,0x4ba9,0x4c7c,
			0x4d4e,0x4e1f,0x4ef0,0x4fc0,0x5090,0x515f,0x522d,0x52fa,0x53c6,0x5492,0x555c,0x5626,0x56ef,0x57b7,0x587d,0x5943,
			0x5a07,0x5acb,0x5b8d,0x5c4e,0x5d0d,0x5dcc,0x5e89,0x5f45,0x5fff,0x60b8,0x6170,0x6226,0x62db,0x638e,0x643f,0x64ef,
			0x659d,0x664a,0x66f5,0x679e,0x6846,0x68ec,0x6990,0x6a32,0x6ad2,0x6b71,0x6c0d,0x6ca8,0x6d40,0x6dd7,0x6e6c,0x6efe,
			0x6f8f,0x701d,0x70aa,0x7134,0x71bc,0x7242,0x72c5,0x7347,0x73c6,0x7443,0x74be,0x7536,0x75ac,0x761f,0x7691,0x7700,
			0x776c,0x77d6,0x783e,0x78a3,0x7905,0x7965,0x79c3,0x7a1e,0x7a77,0x7acd,0x7b20,0x7b71,0x7bbf,0x7c0a,0x7c53,0x7c9a,
			0x7cdd,0x7d1e,0x7d5c,0x7d98,0x7dd1,0x7e07,0x7e3a,0x7e6b,0x7e99,0x7ec4,0x7eed,0x7f12,0x7f35,0x7f55,0x7f73,0x7f8d,
			0x7fa5,0x7fba,0x7fcc,0x7fdc,0x7fe9,0x7ff2,0x7ff9,0x7ffe,0x7fff,0x7ffe,0x7ff9,0x7ff2,0x7fe9,0x7fdc,0x7fcc,0x7fba,
			0x7fa5,0x7f8d,0x7f73,0x7f55,0x7f35,0x7f12,0x7eed,0x7ec4,0x7e99,0x7e6b,0x7e3a,0x7e07,0x7dd1,0x7d98,0x7d5c,0x7d1e,
			0x7cdd,0x7c9a,0x7c53,0x7c0a,0x7bbf,0x7b71,0x7b20,0x7acd,0x7a77,0x7a1e,0x79c3,0x7965,0x7905,0x78a3,0x783e,0x77d6,
			0x776c,0x7700,0x7691,0x761f,0x75ac,0x7536,0x74be,0x7443,0x73c6,0x7347,0x72c5,0x7242,0x71bc,0x7134,0x70aa,0x701d,
			0x6f8f,0x6efe,0x6e6c,0x6dd7,0x6d40,0x6ca8,0x6c0d,0x6b71,0x6ad2,0x6a32,0x6990,0x68ec,0x6846,0x679e,0x66f5,0x664a,
			0x659d,0x64ef,0x643f,0x638e,0x62db,0x6226,0x6170,0x60b8,0x5fff,0x5f45,0x5e89,0x5dcc,0x5d0d,0x5c4e,0x5b8d,0x5acb,
			0x5a07,0x5943,0x587d,0x57b7,0x56ef,0x5626,0x555c,0x5492,0x53c6,0x52fa,0x522d,0x515f,0x5090,0x4fc0,0x4ef0,0x4e1f,
			0x4d4e,0x4c7c,0x4ba9,0x4ad6,0x4a02,0x492e,0x485a,0x4785,0x46b0,0x45db,0x4505,0x442f,0x4359,0x4283,0x41ac,0x40d6,
			0x4000,0x3f29,0x3e53,0x3d7c,0x3ca6,0x3bd0,0x3afa,0x3a24,0x394f,0x387a,0x37a5,0x36d1,0x35fd,0x3529,0x3456,0x3383,
			0x32b1,0x31e0,0x310f,0x303f,0x2f6f,0x2ea0,0x2dd2,0x2d05,0x2c39,0x2b6d,0x2aa3,0x29d9,0x2910,0x2848,0x2782,0x26bc,
			0x25f8,0x2534,0x2472,0x23b1,0x22f2,0x2233,0x2176,0x20ba,0x2000,0x1f47,0x1e8f,0x1dd9,0x1d24,0x1c71,0x1bc0,0x1b10,
			0x1a62,0x19b5,0x190a,0x1861,0x17b9,0x1713,0x166f,0x15cd,0x152d,0x148e,0x13f2,0x1357,0x12bf,0x1228,0x1193,0x1101,
			0x1070,0xfe2,0xf55,0xecb,0xe43,0xdbd,0xd3a,0xcb8,0xc39,0xbbc,0xb41,0xac9,0xa53,0x9e0,0x96e,0x8ff,
			0x893,0x829,0x7c1,0x75c,0x6fa,0x69a,0x63c,0x5e1,0x588,0x532,0x4df,0x48e,0x440,0x3f5,0x3ac,0x365,
			0x322,0x2e1,0x2a3,0x267,0x22e,0x1f8,0x1c5,0x194,0x166,0x13b,0x112,0xed,0xca,0xaa,0x8c,0x72,
			0x5a,0x45,0x33,0x23,0x16,0xd,0x6,0x1,0x0,0x1,0x6,0xd,0x16,0x23,0x33,0x45,
			0x5a,0x72,0x8c,0xaa,0xca,0xed,0x112,0x13b,0x166,0x194,0x1c5,0x1f8,0x22e,0x267,0x2a3,0x2e1,
			0x322,0x365,0x3ac,0x3f5,0x440,0x48e,0x4df,0x532,0x588,0x5e1,0x63c,0x69a,0x6fa,0x75c,0x7c1,0x829,
			0x893,0x8ff,0x96e,0x9e0,0xa53,0xac9,0xb41,0xbbc,0xc39,0xcb8,0xd3a,0xdbd,0xe43,0xecb,0xf55,0xfe2,
			0x1070,0x1101,0x1193,0x1228,0x12bf,0x1357,0x13f2,0x148e,0x152d,0x15cd,0x166f,0x1713,0x17b9,0x1861,0x190a,0x19b5,
			0x1a62,0x1b10,0x1bc0,0x1c71,0x1d24,0x1dd9,0x1e8f,0x1f47,0x2000,0x20ba,0x2176,0x2233,0x22f2,0x23b1,0x2472,0x2534,
			0x25f8,0x26bc,0x2782,0x2848,0x2910,0x29d9,0x2aa3,0x2b6d,0x2c39,0x2d05,0x2dd2,0x2ea0,0x2f6f,0x303f,0x310f,0x31e0,
			0x32b1,0x3383,0x3456,0x3529,0x35fd,0x36d1,0x37a5,0x387a,0x394f,0x3a24,0x3afa,0x3bd0,0x3ca6,0x3d7c,0x3e53,0x3f29
			};
#endif

// * functions for driver/kernel module initialization
static void vss_unregister_all(void);
static int __init alsa_card_vss_init(void);
static void __exit alsa_card_vss_exit(void);

// * declare functions for this struct describing the driver (to be defined later):
#if LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0)
static int __devinit vss_probe(struct platform_device *devptr);
static int __devexit vss_remove(struct platform_device *devptr);
#else
static int vss_probe(struct platform_device *devptr);
static int vss_remove(struct platform_device *devptr);
#endif


// * here declaration of functions that will need to be in _ops, before they are defined
static int vss_hw_params(struct snd_pcm_substream *ss,
                        struct snd_pcm_hw_params *hw_params);
static int vss_hw_free(struct snd_pcm_substream *ss);
static int vss_pcm_open(struct snd_pcm_substream *ss);
static int vss_pcm_close(struct snd_pcm_substream *ss);
static int vss_pcm_prepare(struct snd_pcm_substream *ss);
static int vss_pcm_trigger(struct snd_pcm_substream *ss,
                          int cmd);
static snd_pcm_uframes_t vss_pcm_pointer(struct snd_pcm_substream *ss);

static int vss_pcm_dev_free(struct snd_device *device);
static int vss_pcm_free(struct vss_device *chip);

// * declare timer functions - copied from aloop-kernel.c
static void vss_timer_start(struct vss_device *mydev);
static void vss_timer_stop(struct vss_device *mydev);
static void vss_pos_update(struct vss_device *mydev);
static void vss_timer_function(struct timer_list *t);
static void vss_xfer_buf(struct vss_device *mydev, unsigned int count);
static void vss_fill_capture_buf(struct vss_device *mydev, unsigned int bytes);


// note snd_pcm_ops can usually be separate _playback_ops and _capture_ops
static struct snd_pcm_ops vss_pcm_ops =
{
	.open      = vss_pcm_open,
	.close     = vss_pcm_close,
	.ioctl     = snd_pcm_lib_ioctl,
	.hw_params = vss_hw_params,
	.hw_free   = vss_hw_free,
	.prepare   = vss_pcm_prepare,
	.trigger   = vss_pcm_trigger,
	.pointer   = vss_pcm_pointer,
};

// specifies what func is called @ snd_card_free
// used in snd_device_new
static struct snd_device_ops dev_ops =
{
	.dev_free = vss_pcm_dev_free,
};


#define SND_DRIVER_NAME "snd_vss"

/*
** As this is a virtual device we use a Platform Device.
*/
static struct platform_driver vss_driver =
{
	.probe		= vss_probe,
#if LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0)
	.remove		= __devexit_p(vss_remove),
#else
	.remove		= vss_remove,
#endif
//~ #ifdef CONFIG_PM
	//~ .suspend	= vss_suspend,
	//~ .resume	= vss_resume,
//~ #endif
	.driver		= {
		.name	= SND_DRIVER_NAME,
		.owner = THIS_MODULE
	},
};


/*
 *
 * Probe/remove functions
 *
 */
static int vss_probe(struct platform_device *devptr)
{
	struct snd_card *card;
	struct vss_device *mydev;
	int ret;

	int nr_subdevs; // how many capture substreams we want
	struct snd_pcm *pcm;

	int dev = devptr->id; // from aloop-kernel.c

	dbg("%s: probe", __func__);

	ret = snd_card_new(&devptr->dev, index[dev], id[dev], THIS_MODULE,
		sizeof(struct vss_device), &card);

	if (ret < 0)
		goto __nodev;

	mydev = card->private_data;
	mydev->card = card;
	// MUST have mutex_init here - else crash on mutex_lock!!
	mutex_init(&mydev->cable_lock);

	dbg2("-- mydev %p", mydev);

	sprintf(card->driver, "VIRTUAL vss");
	sprintf(card->shortname, "Signal Source");
	sprintf(card->longname, "Virtual Signal Source (no h/w)");

	ret = snd_device_new(card, SNDRV_DEV_LOWLEVEL, mydev, &dev_ops);

	if (ret < 0)
		goto __nodev;


	nr_subdevs = 1; // how many capture substreams we want
	// * we want 0 playback, and 1 capture substreams (4th and 5th arg) ..
	ret = snd_pcm_new(card, card->driver, 0, 0, nr_subdevs, &pcm);

	if (ret < 0)
		goto __nodev;


	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE, &vss_pcm_ops); // in both aloop-kernel.c and dummy.c, after snd_pcm_new...
	pcm->private_data = mydev; //here it should be dev/card struct (the one containing struct snd_card *card) - this DOES NOT end up in substream->private_data

	pcm->info_flags = 0;
	strcpy(pcm->name, card->shortname);

	/*
	trid to add this - but it crashes here:
	//mydev->substream->private_data = mydev;
	Well, first time real substream comes in, is in _open - so
	that has to be handled there.. That is: at this point, mydev->substream is null,
	and we first have a chance to set it ... in _open!
	*/

	snd_pcm_lib_preallocate_pages_for_all(pcm,
	        SNDRV_DMA_TYPE_CONTINUOUS,
	        snd_dma_continuous_data(GFP_KERNEL),
	        MAX_BUFFER, MAX_BUFFER); // in both aloop-kernel.c and dummy.c, after snd_pcm_set_ops...

	// * will use the snd_card_register form from aloop-kernel.c/dummy.c here..
	ret = snd_card_register(card);

	if (ret == 0)   // or... (!ret)
	{
		platform_set_drvdata(devptr, card);
		return 0; // success
	}

__nodev: // as in aloop/dummy...
	dbg("__nodev reached!!");
	snd_card_free(card); // this will autocall .dev_free (= vss_pcm_dev_free)
	return ret;
}

// from dummy/aloop:
static int vss_remove(struct platform_device *devptr)
{
	dbg("%s", __func__);
	snd_card_free(platform_get_drvdata(devptr));
	platform_set_drvdata(devptr, NULL);
	return 0;
}


/*
 *
 * hw alloc/free functions
 *
 */
static int vss_hw_params(struct snd_pcm_substream *ss,
                        struct snd_pcm_hw_params *hw_params)
{
	dbg("%s", __func__);
	return snd_pcm_lib_malloc_pages(ss,
	                                params_buffer_bytes(hw_params));
}

static int vss_hw_free(struct snd_pcm_substream *ss)
{
	dbg("%s", __func__);
	return snd_pcm_lib_free_pages(ss);
}


/*
 *
 * PCM functions
 *
 */
static int vss_pcm_open(struct snd_pcm_substream *ss)
{
	struct vss_device *mydev = ss->private_data;

	//BREAKPOINT();
	dbg("%s", __func__);

	// copied from aloop-kernel.c:
	mutex_lock(&mydev->cable_lock);

	ss->runtime->hw = vss_pcm_hw;

	mydev->substream = ss; 	//save (system given) substream *ss, in our structure field
	ss->runtime->private_data = mydev;
	mydev->wf_src_pos = 0; 	//init

	// SETUP THE TIMER HERE:
	timer_setup(&mydev->timer, vss_timer_function, 0);

	mutex_unlock(&mydev->cable_lock);
	return 0;
}

static int vss_pcm_close(struct snd_pcm_substream *ss)
{
	struct vss_device *mydev = ss->private_data;

	dbg("%s", __func__);

	// copied from aloop-kernel.c:
	// * even though mutexes are retrieved from ss->private_data,
	// * which will be set to null,
	// * lock the mutex here anyway:
	mutex_lock(&mydev->cable_lock);
	// * not much else to do here, but set to null:
	ss->private_data = NULL;
	mutex_unlock(&mydev->cable_lock);

	return 0;
}


static int vss_pcm_prepare(struct snd_pcm_substream *ss)
{
	// copied from aloop-kernel.c

	// for one, we could get mydev from ss->private_data...
	// here we try it via ss->runtime->private_data instead.
	// turns out, this type of call via runtime->private_data
	// ends up with mydev as null pointer causing SIGSEGV
	// .. UNLESS runtime->private_data is assigned in _open?
	struct snd_pcm_runtime *runtime = ss->runtime;
	struct vss_device *mydev = runtime->private_data;
	unsigned int bps;

	dbg("%s", __func__);

	bps = runtime->rate * runtime->channels; // params requested by user app (arecord, audacity)
	bps *= snd_pcm_format_width(runtime->format);
	bps /= 8;
	if (bps <= 0)
		return -EINVAL;

	mydev->buf_pos = 0;
	mydev->pcm_buffer_size = frames_to_bytes(runtime, runtime->buffer_size);
	dbg2("	bps: %u; runtime->buffer_size: %lu; mydev->pcm_buffer_size: %u", bps, runtime->buffer_size, mydev->pcm_buffer_size);
	if (ss->stream == SNDRV_PCM_STREAM_CAPTURE) {
		/* clear capture buffer */
		mydev->silent_size = mydev->pcm_buffer_size;
		memset(runtime->dma_area, 0, mydev->pcm_buffer_size);
	}

	if (!mydev->running) {
		mydev->irq_pos = 0;
		mydev->period_update_pending = 0;
	}

	mutex_lock(&mydev->cable_lock);
	if (!(mydev->valid & ~(1 << ss->stream))) {
		mydev->pcm_bps = bps;
		mydev->pcm_period_size =
			frames_to_bytes(runtime, runtime->period_size);
		mydev->period_size_frac = frac_pos(mydev->pcm_period_size);

	}
	mydev->valid |= 1 << ss->stream;
	mutex_unlock(&mydev->cable_lock);

	dbg2("	pcm_period_size: %u; period_size_frac: %u", mydev->pcm_period_size, mydev->period_size_frac);

	return 0;
}


static int vss_pcm_trigger(struct snd_pcm_substream *ss,
                          int cmd)
{
	int ret = 0;
	//copied from aloop-kernel.c

	//here we do not get mydev from
	// ss->runtime->private_data; but from:
	struct vss_device *mydev = ss->private_data;

	dbg("%s - trig %d", __func__, cmd);

	switch (cmd)
	{
		case SNDRV_PCM_TRIGGER_START:
			// Start the hardware capture
			// from aloop-kernel.c:
			if (!mydev->running) {
				mydev->last_jiffies = jiffies;
				// SET OFF THE TIMER HERE:
				vss_timer_start(mydev);
			}
			mydev->running |= (1 << ss->stream);
			break;
		case SNDRV_PCM_TRIGGER_STOP:
			// Stop the hardware capture
			// from aloop-kernel.c:
			mydev->running &= ~(1 << ss->stream);
			if (!mydev->running)
				// STOP THE TIMER HERE:
				vss_timer_stop(mydev);
			break;
		default:
			ret = -EINVAL;
	}

	return ret;
}


static snd_pcm_uframes_t vss_pcm_pointer(struct snd_pcm_substream *ss)
{
	//copied from aloop-kernel.c
	struct snd_pcm_runtime *runtime = ss->runtime;
	struct vss_device *mydev= runtime->private_data;

	dbg2("+vss_pointer ");
	vss_pos_update(mydev);
	dbg2("+	bytes_to_frames(: %lu, mydev->buf_pos: %d", bytes_to_frames(runtime, mydev->buf_pos),mydev->buf_pos);
	return bytes_to_frames(runtime, mydev->buf_pos);

}


/*
 *
 * Timer functions
 *
 */
static void vss_timer_start(struct vss_device *mydev)
{
	unsigned long tick;
	dbg2("vss_timer_start: mydev->period_size_frac: %u; mydev->irq_pos: %u jiffies: %lu pcm_bps %u", mydev->period_size_frac, mydev->irq_pos, jiffies, mydev->pcm_bps);
	tick = mydev->period_size_frac - mydev->irq_pos;
	tick = (tick + mydev->pcm_bps - 1) / mydev->pcm_bps;
	mydev->timer.expires = jiffies + tick;
	add_timer(&mydev->timer);
}

static void vss_timer_stop(struct vss_device *mydev)
{
	dbg2("vss_timer_stop");
	del_timer(&mydev->timer);
}

static void vss_pos_update(struct vss_device *mydev)
{
	unsigned int last_pos, count;
	unsigned long delta;

	if (!mydev->running)
		return;

	dbg2("*vss_pos_update: running ");

	delta = jiffies - mydev->last_jiffies;
	dbg2("*	: jiffies %lu, ->last_jiffies %lu, delta %lu", jiffies, mydev->last_jiffies, delta);

	if (!delta)
		return;

	mydev->last_jiffies += delta;

	last_pos = byte_pos(mydev->irq_pos);
	mydev->irq_pos += delta * mydev->pcm_bps;
	count = byte_pos(mydev->irq_pos) - last_pos;
	dbg2("*	: last_pos %d, c->irq_pos %d, count %d", last_pos, mydev->irq_pos, count);

	if (!count)
		return;

	// FILL BUFFER HERE
	vss_xfer_buf(mydev, count);

	if (mydev->irq_pos >= mydev->period_size_frac)
	{
		dbg2("*	: mydev->irq_pos >= mydev->period_size_frac %d", mydev->period_size_frac);
		mydev->irq_pos %= mydev->period_size_frac;
		mydev->period_update_pending = 1;
	}
}

static void vss_timer_function(struct timer_list *t)
{
	struct vss_device *mydev = (struct vss_device *) from_timer(mydev, t, timer);

	if (!mydev->running)
		return;

	dbg2("vss_timer_function: running ");
	vss_pos_update(mydev);
	// SET OFF THE TIMER HERE:
	vss_timer_start(mydev);

	if (mydev->period_update_pending)
	{
		mydev->period_update_pending = 0;

		if (mydev->running)
		{
			dbg2("	: calling snd_pcm_period_elapsed");
			snd_pcm_period_elapsed(mydev->substream);
		}
	}
}

#define CABLE_PLAYBACK	(1 << SNDRV_PCM_STREAM_PLAYBACK)
#define CABLE_CAPTURE	(1 << SNDRV_PCM_STREAM_CAPTURE)
#define CABLE_BOTH	(CABLE_PLAYBACK | CABLE_CAPTURE)

static void vss_xfer_buf(struct vss_device *mydev, unsigned int count)
{

	dbg2(">vss_xfer_buf: count: %d ", count );

	switch (mydev->running) {
	case CABLE_CAPTURE:
		vss_fill_capture_buf(mydev, count);
		break;
	}

		if (mydev->running) {
			// Nothing to do.
		}
}

static void vss_fill_capture_buf(struct vss_device *mydev, unsigned int bytes)
{
	char *dst = mydev->substream->runtime->dma_area;
	unsigned int dst_off = mydev->buf_pos; // buf_pos is in bytes, not in samples !
	int8_t silence;
	unsigned int dpos = 0;
	int j = 0;

	dbg2("_ vss_fill_capture_buf ss %d bs %d bytes %d buf_pos %d sizeof %ld jiffies %lu", mydev->silent_size, mydev->pcm_buffer_size, bytes, dst_off, sizeof(*dst), jiffies);

	// This is minivosc's 'COPYALG_V2'.
	// hmm... for this loop, v2,  I was getting prepare signature (45), if
	//   mydev->buf_pos autoincrements (wraps) in vss_xfer_buf ;
	// however, for more correct, we calculate 'buf_pos' here instead..
	// using direct assignment of elements for copying/filling
	//
	for (j=0; j<bytes; j++) {
		dst[mydev->buf_pos] = sine_1k_data8[mydev->wf_src_pos] + 0x40; // Offset data to make it symmetrical
		dpos++; mydev->buf_pos++;
		mydev->wf_src_pos++;

		if (mydev->wf_src_pos >= sizeof(sine_1k_data8)) { // we should wrap waveform here..
			mydev->wf_src_pos = 0;
		}
		if (mydev->buf_pos >= mydev->pcm_buffer_size) {
			mydev->buf_pos = 0;
			//break; //we don;t really need this
		}
		if (dpos >= bytes) break;
	}

	if (mydev->silent_size >= mydev->pcm_buffer_size)
		return;

	// NOTE: usually, the code returns by now -
	// - it doesn't even execute past this point!
	// from here on, apparently silent_size should be handled..

	if (mydev->silent_size + bytes > mydev->pcm_buffer_size)
		bytes = mydev->pcm_buffer_size - mydev->silent_size;

	silence = 0; // Value to copy for silence (if needed).

	for (;;) {
		unsigned int size = bytes;
		dpos = 0; //added
		dbg2("_ clearrr..	%d", bytes);
		if (dst_off + size > mydev->pcm_buffer_size)
			size = mydev->pcm_buffer_size - dst_off;

		//memset(dst + dst_off, 255, size); //0, size);
		while (dpos < size)
		{
			memcpy(dst + dst_off + dpos, &silence, sizeof(silence));
			dpos += sizeof(silence);
			if (dpos >= size) break;
		}
		mydev->silent_size += size;
		bytes -= size;
		if (!bytes)
			break;
		dst_off = 0;
	}
}





/*
 *
 * snd_device_ops free functions
 *
 */
// these should eventually get called by snd_card_free (via .dev_free)
// however, since we do no special allocations, we need not free anything
static int vss_pcm_free(struct vss_device *chip)
{
	dbg("%s", __func__);
	return 0;
}

static int vss_pcm_dev_free(struct snd_device *device)
{
	dbg("%s", __func__);
	return vss_pcm_free(device->device_data);
}



/*
 *
 * functions for driver/kernel module initialization
 * (_init, _exit)
 * copied from aloop-kernel.c (same in dummy.c)
 *
 */
static void vss_unregister_all(void)
{
	int i;

	dbg("%s", __func__);

	for (i = 0; i < ARRAY_SIZE(devices); ++i)
		platform_device_unregister(devices[i]);

	platform_driver_unregister(&vss_driver);
}

static int __init alsa_card_vss_init(void)
{
	int i, err, cards;

	dbg("%s", __func__);
	err = platform_driver_register(&vss_driver);

	if (err < 0)
		return err;


	cards = 0;

	for (i = 0; i < SNDRV_CARDS; i++)
	{
		struct platform_device *device;

		if (!enable[i])
			continue;

		device = platform_device_register_simple(SND_DRIVER_NAME,
		         i, NULL, 0);

		if (IS_ERR(device))
			continue;

		if (!platform_get_drvdata(device))
		{
			platform_device_unregister(device);
			continue;
		}

		devices[i] = device;
		cards++;
	}

	if (!cards)
	{
#ifdef MODULE
		printk(KERN_ERR "%s: Not enabled, not found or device busy\n", SND_DRIVER_NAME);
#endif
		vss_unregister_all();
		return -ENODEV;
	}

	return 0;
}

static void __exit alsa_card_vss_exit(void)
{
	dbg("%s", __func__);
	vss_unregister_all();
}

module_init(alsa_card_vss_init)
module_exit(alsa_card_vss_exit)
